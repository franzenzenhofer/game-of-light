// Generated by CoffeeScript 1.6.3
(function() {
  var BULLET_SHOOTER_RATIO, DEFAULT_NEGATIVE_CIRCLE_JOIN_RATE, DEFAULT_USER_ACCELERATION, DRAW_BIGGER_RADIUS_FACTOR, ENEMIES_PROPABILITY, MAX_ENEMY_RADIUS, MAX_ENEMY_SPEED, MAX_USER_SPEED, MINIMAL_VIABLE_RADIUS, MIN_ENEMY_RADIUS, MIN_ENEMY_SPEED, NUMBER_OF_ENEMIES, PLAYER_START_SIZE, PROPORTION_MAX_NEW_ENEMY_SIZE, RATIO_PREVAILANCE_WITH_MERGE, SHOOTER_SHOOT_LOSS, bubbleCollision, c, calcCircleBox, circle, circleCollision, clamp, clampRgb, colorMix, dlog, doTheCirclesColide, drawCircle, drawCircleBox, drawCircleExplosion, getA, getADifference, getADifferenceMinusRadius, getRadiusByArea, init, isCircleViable, joinBubbles, joinCircles, limitPlayerVelocity, makeBubble, makeColorString, makeEnemy, makePlayer, maxEnemySize, maxEnemyVelocity, moveBubble, moveBubbleWithinBounds, movePlayer, randomColor, randomInt, randomNumber, randomPlusOrMinusOne, rc, rectangleCollision, reverse_circle, spawnEnemy, spawnPlayer, zeroTo255, _DEBUG_;

  _DEBUG_ = true;

  ENEMIES_PROPABILITY = 0.05;

  NUMBER_OF_ENEMIES = 100;

  MIN_ENEMY_SPEED = 0.5;

  MAX_ENEMY_SPEED = 1;

  PLAYER_START_SIZE = 20;

  DEFAULT_USER_ACCELERATION = 0.1;

  MAX_USER_SPEED = 4;

  DEFAULT_NEGATIVE_CIRCLE_JOIN_RATE = 0.5;

  RATIO_PREVAILANCE_WITH_MERGE = 0.8;

  MINIMAL_VIABLE_RADIUS = 1;

  MAX_ENEMY_RADIUS = 450;

  MIN_ENEMY_RADIUS = 1;

  PROPORTION_MAX_NEW_ENEMY_SIZE = 12.0;

  BULLET_SHOOTER_RATIO = 0.2;

  SHOOTER_SHOOT_LOSS = 0.01;

  DRAW_BIGGER_RADIUS_FACTOR = 1.4;

  dlog = function(msg) {
    if (_DEBUG_) {
      console.log(msg);
    }
    return msg;
  };

  randomInt = function(from, to) {
    return Math.floor(Math.random() * to) + from;
  };

  randomNumber = function(from, to) {
    return (Math.random() * to) + from;
  };

  randomPlusOrMinusOne = function() {
    if (Math.random() < 0.5) {
      return -1;
    } else {
      return 1;
    }
  };

  clamp = function(v, min, max) {
    return Math.min(Math.max(v, min), max);
  };

  clampRgb = function(v) {
    return parseInt(clamp(v, 0, 255));
  };

  zeroTo255 = function(n) {
    while (n == null) {
      return randomInt(0, 255);
    }
    if (n < 0 || n > 255) {
      return randomInt(0, 255);
    }
    return parseInt(n);
  };

  randomColor = function(r, g, b) {
    return [zeroTo255(r), zeroTo255(g), zeroTo255(b)];
  };

  makeColorString = function(color_rgb) {
    var b, g, r;
    r = color_rgb[0], g = color_rgb[1], b = color_rgb[2];
    return "rgb(" + r + "," + g + "," + b + ")";
  };

  c = circle = function(x, y, r) {
    return [x, y, r];
  };

  rc = reverse_circle = function(a) {
    var r, x, y;
    return x = a[0], y = a[1], r = a[2], a;
  };

  calcCircleBox = function(circle) {
    var r, x, y, _ref;
    _ref = rc(circe), x = _ref[0], y = _ref[1], r = _ref[2];
    return [x - r, y - r, r * 2];
  };

  doTheCirclesColide = function(circle_0, circle_1) {};

  isCircleViable = function(circle) {};

  joinCircles = function(circle_0, circle_1) {};

  maxEnemySize = function(player) {
    return Math.floor(Math.sqrt(player.circle[2]) * PROPORTION_MAX_NEW_ENEMY_SIZE);
  };

  maxEnemyVelocity = function(player) {
    return Math.max.apply(Math, [player.vx, player.vy]);
  };

  moveBubble = function(bubble) {
    bubble.circle[0] = bubble.circle[0] + bubble.vx;
    bubble.circle[1] = bubble.circle[1] + bubble.vy;
    return bubble;
  };

  limitPlayerVelocity = function(v) {
    if (Math.abs(v) > MAX_USER_SPEED) {
      return MAX_USER_SPEED * (v / Math.abs(v));
    } else {
      return v;
    }
  };

  movePlayer = function(active_commands, w, h, p) {
    var command, _fn, _i, _len;
    _fn = function(command) {
      if (command === 'up') {
        p.vy = p.vy - DEFAULT_USER_ACCELERATION;
        return p.vy = limitPlayerVelocity(p.vy);
      } else if (command === 'down') {
        p.vy = p.vy + DEFAULT_USER_ACCELERATION;
        return p.vy = limitPlayerVelocity(p.vy);
      } else if (command === 'left') {
        p.vx = p.vx - DEFAULT_USER_ACCELERATION;
        return p.vx = limitPlayerVelocity(p.vx);
      } else if (command === 'right') {
        p.vx = p.vx + DEFAULT_USER_ACCELERATION;
        return p.vx = limitPlayerVelocity(p.vx);
      } else {
        return dlog('unkown command: ' + c);
      }
    };
    for (_i = 0, _len = active_commands.length; _i < _len; _i++) {
      command = active_commands[_i];
      _fn(command);
    }
    return moveBubbleWithinBounds(w, h, p);
  };

  moveBubbleWithinBounds = function(w, h, bubble) {
    var r, x, y, _ref;
    _ref = bubble.circle, x = _ref[0], y = _ref[1], r = _ref[2];
    if (y < (r * -1)) {
      bubble.circle[1] = h + r;
      return moveBubble(bubble);
    } else if (y > (h + r)) {
      bubble.circle[1] = r * -1;
      return moveBubble(bubble);
    } else if (x < (r * -1)) {
      bubble.circle[0] = w + r;
      return moveBubble(bubble);
    } else if (x > w + r) {
      bubble.circle[0] = r * -1;
      return moveBubble(bubble);
    } else {
      return moveBubble(bubble);
    }
  };

  makeBubble = function(x, y, r, vx, vy, rgb) {
    var b;
    if (x == null) {
      x = 100;
    }
    if (y == null) {
      y = 100;
    }
    if (r == null) {
      r = 100;
    }
    if (vx == null) {
      vx = 0;
    }
    if (vy == null) {
      vy = 0;
    }
    b = {};
    b.circle = c(x, y, r);
    b.fillColor = rgb != null ? rgb : randomColor();
    b.strokeColor = [0, 0, 255];
    b.alive = true;
    b.explode = false;
    b.vx = vx;
    b.vy = vy;
    return b;
  };

  makeEnemy = function(x, y, r, vx, vy, rgb) {
    if (r > MAX_ENEMY_RADIUS) {
      r = MAX_ENEMY_RADIUS;
    }
    return makeBubble(x, y, r, vx, vy, rgb);
  };

  makePlayer = function(x, y, r) {
    return makeBubble(x, y, r, 0, 0, [255, 255, 0]);
  };

  spawnPlayer = function(w, h) {
    return makePlayer(Math.floor(w / 2), Math.floor(h / 2), PLAYER_START_SIZE);
  };

  spawnEnemy = function(world_width, world_height, min_r, max_r, min_v, max_v) {
    var r, vx, vy, where, x, y;
    if (min_r == null) {
      min_r = 15;
    }
    if (max_r == null) {
      max_r = 75;
    }
    if (min_v == null) {
      min_v = MIN_ENEMY_SPEED;
    }
    if (max_v == null) {
      max_v = MAX_ENEMY_SPEED;
    }
    r = randomInt(min_r, max_r);
    vx = randomNumber(min_v, max_v);
    vy = randomNumber(min_v, max_v);
    where = Math.random();
    switch (false) {
      case !(where < 0.25):
        x = Math.random() * world_width;
        y = r * -1;
        vx = vx * randomPlusOrMinusOne();
        break;
      case !(where < 0.5):
        x = Math.random() * world_width;
        y = world_height + r;
        vy = vy * -1;
        vx = vx * randomPlusOrMinusOne();
        break;
      case !(where < 0.75):
        x = r * -1;
        y = Math.random() * world_height;
        vy = vy * randomPlusOrMinusOne();
        vx = vx;
        break;
      default:
        x = world.width + r;
        y = Math.random() * world_height;
        vy = vy * randomPlusOrMinusOne();
        vx = vx * -1;
    }
    return makeEnemy(x, y, r, vx, vy);
  };

  rectangleCollision = function(a, b) {
    var a_width, a_x, a_y, b_width, b_x, b_y;
    a_x = a[0], a_y = a[1], a_width = a[2];
    b_x = b[0], b_y = b[1], b_width = b[2];
    return a_x < b_x + b_width && a_x + a_width > b_x && a_y < b_y + b_width && a_y + a_width > b_y;
  };

  circleCollision = function(c1, c2) {
    var a, b, c1_r, c1_x, c1_y, c2_r, c2_x, c2_y, d, _ref, _ref1;
    _ref = rc(c1), c1_x = _ref[0], c1_y = _ref[1], c1_r = _ref[2];
    _ref1 = rc(c2), c2_x = _ref1[0], c2_y = _ref1[1], c2_r = _ref1[2];
    a = c2_x - c1_x;
    b = c2_y - c1_y;
    d = Math.sqrt(a * a + b * b);
    if ((d - c1_r - c2_r) < 0) {
      return true;
    }
    return false;
  };

  bubbleCollision = function(b1, b2) {
    var c1_r, c1_x, c1_y, c2_r, c2_x, c2_y, _ref, _ref1;
    _ref = rc(b1.circle), c1_x = _ref[0], c1_y = _ref[1], c1_r = _ref[2];
    _ref1 = rc(b2.circle), c2_x = _ref1[0], c2_y = _ref1[1], c2_r = _ref1[2];
    if (rectangleCollision([c1_x - (c1_r / 2), c1_y - (c1_y / 2), c1_r * 2], [c2_x - (c2_r / 2), c2_y - (c2_y / 2), c2_r * 2])) {
      return circleCollision(b1.circle, b2.circle);
    }
    return false;
  };

  getA = function(circle) {
    return circle[2] * circle[2] * Math.PI;
  };

  getADifference = function(c1, c2) {
    return Math.abs(getA(c1) - getA(c2));
  };

  getRadiusByArea = function(a) {
    return Math.sqrt(a / Math.PI);
  };

  getADifferenceMinusRadius = function(circle, minus) {
    var c2;
    c2 = [circle[0], circle[1], circle[2] - minus];
    return getADifference(circle, c2);
  };

  colorMix = function(rgb1, rgb2, percentage) {
    var b1, b2, b_diff, b_faktor, b_n, g1, g2, g_diff, g_faktor, g_n, r1, r2, r_diff, r_faktor, r_n;
    r1 = rgb1[0], g1 = rgb1[1], b1 = rgb1[2];
    r2 = rgb2[0], g2 = rgb2[1], b2 = rgb2[2];
    if (r1 + g1 + b1 > 255) {
      r_faktor = 1;
      if (r1 < r2) {
        r_faktor = r_faktor * -1;
      }
      g_faktor = 1;
      if (g1 < g2) {
        g_faktor = g_faktor * -1;
      }
      b_faktor = 1;
      if (b1 < b2) {
        b_faktor = b_faktor * -1;
      }
    } else {
      r_faktor = g_faktor = b_faktor = 1;
    }
    r_diff = Math.abs(r1 - r2);
    g_diff = Math.abs(g1 - g2);
    b_diff = Math.abs(b1 - b2);
    r_n = clampRgb(r1 + (r_diff * percentage * r_faktor));
    g_n = clampRgb(g1 + (g_diff * percentage * g_faktor));
    b_n = clampRgb(b1 + (b_diff * percentage * b_faktor));
    return [r_n, g_n, b_n];
    dlog(r1 + '-' + r2 + '=' + r_diff + '+' + r1 + '');
    return [r_new, g_new, b_new];
  };

  joinBubbles = function(b1, b2) {
    var c1_r, c1_x, c1_y, c2_r, c2_x, c2_y, looser, looser_area_difference, percentage_of_area, winner, winner_area, _ref, _ref1;
    _ref = rc(b1.circle), c1_x = _ref[0], c1_y = _ref[1], c1_r = _ref[2];
    _ref1 = rc(b2.circle), c2_x = _ref1[0], c2_y = _ref1[1], c2_r = _ref1[2];
    if (c1_r > c2_r) {
      winner = b1;
      looser = b2;
    } else if (c1_r < c2_r) {
      winner = b2;
      looser = b1;
    } else {
      if (Math.random() <= 0.5) {
        b1.explode = true;
        b1.alive = false;
      } else {
        b2.explode = true;
        b2.alive = false;
      }
      return true;
    }
    winner.strokeColor = [0, 255, 0];
    looser.strokeColor = [255, 0, 0];
    if (winner && looser) {
      looser_area_difference = getADifferenceMinusRadius(looser.circle, DEFAULT_NEGATIVE_CIRCLE_JOIN_RATE);
      looser.circle[2] = looser.circle[2] - DEFAULT_NEGATIVE_CIRCLE_JOIN_RATE;
      winner_area = getA(winner.circle);
      percentage_of_area = looser_area_difference / winner_area;
      winner.fillColor = colorMix(winner.fillColor, looser.fillColor, percentage_of_area);
      winner.circle[2] = getRadiusByArea(winner_area + (looser_area_difference * RATIO_PREVAILANCE_WITH_MERGE));
      if (looser.circle[2] < MINIMAL_VIABLE_RADIUS) {
        looser.alive = false;
      }
    }
    return true;
  };

  drawCircleBox = function(circle, ctx) {};

  drawCircle = function(ctx, circle, fill, border) {
    var gradient, r, x, y, _ref;
    if (fill == null) {
      fill = randomColor();
    }
    if (border == null) {
      border = [0, 0, 255];
    }
    _ref = rc(circle), x = _ref[0], y = _ref[1], r = _ref[2];
    if (r <= 0) {
      return false;
    }
    ctx.globalCompositeOperation = "lighter";
    ctx.lineWidth = 2;
    gradient = ctx.createRadialGradient(x, y, 0, x, y, r * DRAW_BIGGER_RADIUS_FACTOR);
    gradient.addColorStop(0.4, makeColorString(fill));
    gradient.addColorStop(1, "black");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc((0.5 + x) | 0, (0.5 + y) | 0, (0.5 + r * DRAW_BIGGER_RADIUS_FACTOR) | 0, 0, 2 * Math.PI);
    return ctx.fill();
  };

  drawCircleExplosion = function(circle, options, board_cxt) {};

  init = function(w) {
    var currently_active_commands, event2Command, game, getActiveCommands, removeActiveCommand, setActiveCommand, world_height, world_width;
    dlog('in init');
    world_width = w.width = window.innerWidth;
    world_height = w.height = window.innerHeight;
    document.addEventListener('keydown', function(event) {
      var command;
      event.preventDefault();
      command = event2Command(event);
      if (command) {
        return setActiveCommand(command);
      }
    });
    document.addEventListener('keyup', function(event) {
      var command;
      event.preventDefault();
      command = event2Command(event);
      if (command) {
        return removeActiveCommand(command);
      }
    });
    currently_active_commands = [];
    event2Command = function(event) {
      if (event.keyCode === 40) {
        return 'down';
      }
      if (event.keyCode === 38) {
        return 'up';
      }
      if (event.keyCode === 37) {
        return 'left';
      }
      if (event.keyCode === 39) {
        return 'right';
      }
      return false;
    };
    getActiveCommands = function() {
      return currently_active_commands;
    };
    setActiveCommand = function(command) {
      if (currently_active_commands.indexOf(command) === -1) {
        currently_active_commands.push(command);
      }
      return dlog(currently_active_commands);
    };
    removeActiveCommand = function(command) {
      var co, temp, _fn, _i, _len;
      temp = [];
      _fn = function(co) {
        if (co !== command) {
          return temp.push(co);
        }
      };
      for (_i = 0, _len = currently_active_commands.length; _i < _len; _i++) {
        co = currently_active_commands[_i];
        _fn(co);
      }
      currently_active_commands = temp;
      return dlog(currently_active_commands);
    };
    game = function(w, max_nr_of_enemies, chance_of_new_enemy, min_enemy_speed, max_enemy_speed, number_of_active_players) {
      var cache_canvas, cctx, draw, enemies, players, run, update, wctx;
      if (number_of_active_players == null) {
        number_of_active_players = 1;
      }
      wctx = w.getContext('2d');
      cache_canvas = document.createElement('canvas');
      cache_canvas.width = world_width;
      cache_canvas.height = world_height;
      cctx = cache_canvas.getContext('2d');
      dlog('in game');
      enemies = [];
      players = [];
      update = function() {
        var all_bubbles, b, b2, e, i, i2, p, players_and_enemies, temp, _fn, _fn1, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m;
        if (players.length < number_of_active_players) {
          players.push(spawnPlayer(world_width, world_height));
        }
        if (enemies.length < max_nr_of_enemies && Math.random() < chance_of_new_enemy) {
          enemies.push(spawnEnemy(world_width, world_height, MIN_ENEMY_RADIUS, maxEnemySize(players[0]), MIN_ENEMY_SPEED, maxEnemyVelocity(players[0])));
        }
        _fn = function(e) {
          return moveBubbleWithinBounds(world_width, world_height, e);
        };
        for (_i = 0, _len = enemies.length; _i < _len; _i++) {
          e = enemies[_i];
          _fn(e);
        }
        _fn1 = function(p) {
          return movePlayer(getActiveCommands(), world_width, world_height, p);
        };
        for (_j = 0, _len1 = players.length; _j < _len1; _j++) {
          p = players[_j];
          _fn1(p);
        }
        players_and_enemies = players.concat(enemies);
        for (i = _k = 0, _len2 = players_and_enemies.length; _k < _len2; i = ++_k) {
          b = players_and_enemies[i];
          for (i2 = _l = 0, _len3 = players_and_enemies.length; _l < _len3; i2 = ++_l) {
            b2 = players_and_enemies[i2];
            if (i !== i2 && circleCollision(b.circle, b2.circle)) {
              joinBubbles(b, b2);
            }
          }
        }
        temp = [];
        for (_m = 0, _len4 = players_and_enemies.length; _m < _len4; _m++) {
          b = players_and_enemies[_m];
          if (b.alive !== false) {
            temp.push(b);
          }
        }
        players_and_enemies = temp;
        all_bubbles = players_and_enemies;
        return all_bubbles;
      };
      draw = function(bubbles) {
        var b, _i, _len;
        cctx.clearRect(0, 0, world_width, world_height);
        cctx.fillStyle = "rgba(0, 0, 0, 0.3)";
        cctx.fillRect(0, 0, world_width, world_height);
        for (_i = 0, _len = bubbles.length; _i < _len; _i++) {
          b = bubbles[_i];
          drawCircle(cctx, b.circle, b.fillColor, b.strokeColor);
        }
        return wctx.drawImage(cache_canvas, 0, 0);
      };
      run = function() {
        var bubbles;
        window.stats.begin();
        window.requestAnimationFrame(run);
        bubbles = update();
        draw(bubbles);
        return window.stats.end();
      };
      return run();
    };
    return game(w, NUMBER_OF_ENEMIES, ENEMIES_PROPABILITY);
  };

  init(document.getElementById('world'));

}).call(this);
